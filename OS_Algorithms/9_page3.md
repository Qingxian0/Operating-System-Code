# 分页式存储管理

## `std::shared_ptr`和`std::unique_ptr`的区别

在这里使用 `std::make_shared` 而不是 `std::make_unique` 主要是因为 `std::shared_ptr` 和 `std::unique_ptr` 在使用场景上的不同。具体来说：

1. **所有权管理**：
   - `std::shared_ptr` 用于需要共享所有权的场景，可以在多个地方同时持有该对象的指针。当最后一个 `std::shared_ptr` 被销毁时，才会释放内存。
   - `std::unique_ptr` 则用于独占所有权的场景，意味着一个 `std::unique_ptr` 所持有的对象不能同时被另一个 `std::unique_ptr` 持有。这保证了内存的独占性，但在需要多处引用该对象时不方便。
2. **项目需求**：
   在这个项目中，内存对象（`Memory` 类的实例）需要在多个地方引用和使用，比如在内存分配和回收函数中，所有作业对象都需要引用同一个内存对象。这种场景下，`std::shared_ptr` 可以更好地管理多个引用，确保对象在所有引用被销毁前不会被释放，从而避免悬空指针问题。
3. **易用性**：
   使用 `std::make_shared` 创建的对象会自动管理引用计数，方便内存的自动回收，减少了手动管理内存的复杂度。

因此，使用 `std::make_shared` 更适合这种需要共享所有权的场景。而 `std::make_unique` 则适合于单一所有权，不需要在多个地方引用同一对象的情况。

总结起来，`std::make_shared` 被选用是为了方便内存管理，确保内存对象可以在多个地方安全地引用和使用。

## 为什么要用`std::shard_ptr`？

在这个代码中使用 `std::shared_ptr` 主要有以下几个原因：

### 1. **内存管理**

`shared_ptr` 是 C++11 标准库提供的一种智能指针，能够自动管理对象的生命周期，防止内存泄漏。当最后一个指向对象的 `shared_ptr` 被销毁时，对象会被自动删除，从而避免了显式的 `delete` 操作和可能的内存管理错误。

### 2. **简化代码**

使用 `shared_ptr` 可以简化代码中对象的创建和销毁过程。传统的指针需要显式地删除，容易出现忘记删除或多次删除同一指针的情况，而 `shared_ptr` 可以自动处理这些问题。

### 3. **共享所有权**

在这个代码中，作业（Job）对象是通过链表链接在一起的，头节点（head）指向第一个作业对象。使用 `shared_ptr` 可以轻松实现对象的共享所有权。例如，当一个作业对象被插入链表或从链表中移除时，可以确保在整个链表中正确管理对象的生命周期，而不需要担心手动管理内存的复杂性。

### 具体示例

假设有以下情况：我们需要在多个地方引用同一个作业对象。如果使用原始指针，必须非常小心地管理对象的生存周期，避免多次删除同一个对象，或者在对象已被删除后访问它。而使用 `shared_ptr` 可以简化这些操作：

```cpp
std::shared_ptr<Job> job1 = std::make_shared<Job>("Job1", 10);
std::shared_ptr<Job> job2 = job1; // job2 也指向 job1，此时引用计数为2
// job1 和 job2 可以独立使用，当它们都超出作用域时，Job 对象会自动销毁
```

### 总结

使用 `shared_ptr` 可以大幅简化内存管理，减少代码中的错误，尤其是在涉及复杂的对象所有权关系时。它提供了一个安全、高效的方式来管理对象的生命周期，使代码更简洁、更易于维护。
